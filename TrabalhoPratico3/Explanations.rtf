{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fnil\fcharset0 Consolas;}
{\colortbl;\red255\green255\blue255;\red27\green29\blue31;\red255\green255\blue255;\red8\green69\blue135;
\red235\green236\blue237;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl390\sa300

\f0\fs30 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 That means you're restricted by the {\field{\*\fldinst{HYPERLINK "https://wiki.python.org/moin/GlobalInterpreterLock"}}{\fldrslt \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Global Interpreter Lock (GIL)}}, and only one thread can actually execute CPU-bound operations at a time. That's going to keep you from fully utilizing your CPUs. If you want get full parallelism across all available cores, you're going to need to address the pickling issue you're hitting with 
\f1\fs26 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 multiprocessing.Pool
\f0\fs30 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 .\
Note that 
\f1\fs26 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 multiprocessing.dummy
\f0\fs30 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  might still be useful if the work you need to parallelize is IO bound, or utilizes a C-extension that releases the GIL. For pure Python code, however, you'll need 
\f1\fs26 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 multiprocessing
\f0\fs30 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 .\
}